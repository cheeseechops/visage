{% extends "base.html" %}
{% block title %}Uncropped Image Processor{% endblock %}
{% block content %}
<div class="min-h-screen bg-[#181a20] flex flex-row items-start pt-12 py-8 px-8">
  <!-- Left: Upcoming Uncropped Thumbnails -->
  <div class="flex flex-col items-center gap-2 mr-6 min-w-[80px]" id="upcoming-thumbnails"></div>
  <div class="max-w-full w-full bg-[#23263a] rounded-lg shadow-lg p-8 flex flex-row gap-12 px-0">
    <!-- Left: Uncropped Image -->
    <div class="w-1/4 flex flex-col items-center pl-4" id="main-image-col">
      <div id="main-image-loader" class="w-full h-[75vh] flex items-center justify-center">
        <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-400"></div>
      </div>
      <img id="main-image" src="" alt="Uncropped Image" class="hidden rounded-lg border-2 border-gray-700 max-h-[75vh] max-w-full w-full h-auto object-contain mb-4 bg-[#181a20]">
      <!-- Rotation buttons -->
      <div id="rotation-buttons" class="hidden flex flex-row gap-2 mb-4">
        <button id="rotate-ccw-btn" class="px-4 py-2 bg-blue-700 text-white rounded shadow hover:bg-blue-800 focus:outline-none inline-flex items-center">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
          </svg>
          Rotate Left
        </button>
        <button id="rotate-cw-btn" class="px-4 py-2 bg-blue-700 text-white rounded shadow hover:bg-blue-800 focus:outline-none inline-flex items-center">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
          </svg>
          Rotate Right
        </button>
      </div>
      <div id="main-image-meta" class="hidden">
        <div class="text-gray-300 text-sm mb-2">ID: <span class="font-semibold text-primary" id="main-image-id"></span></div>
        <div class="text-gray-400 text-xs" id="main-image-filename"></div>
      </div>
    </div>
    <!-- Right: YOLO Crops Grid Placeholder -->
    <div class="w-3/4 flex flex-col pr-4">
      <div class="flex flex-row gap-4 mb-6">
        <button id="skip-btn" class="px-6 py-2 bg-gray-700 text-gray-200 rounded shadow hover:bg-gray-600 focus:outline-none inline-block text-center">Skip</button>
        <button id="delete-btn" class="px-6 py-2 bg-red-700 text-white rounded shadow hover:bg-red-800 focus:outline-none inline-block text-center">Delete</button>
        <button id="confirm-multiselect-btn" class="hidden px-6 py-2 bg-green-700 text-white rounded shadow hover:bg-green-800 focus:outline-none inline-block text-center">Confirm Selection</button>
      </div>
      <h2 class="text-lg font-semibold mb-4 text-gray-100">Detected People (YOLO)</h2>
      <div id="yolo-crops-grid" class="grid grid-cols-4 gap-8 p-2 min-h-[320px] flex-1 w-full items-start">
        <div id="yolo-loading" class="col-span-2 text-center text-gray-500">Detecting people with YOLO...</div>
      </div>
    </div>
  </div>
  <!-- Right: Last 10 Crops Saved -->
  <div class="flex flex-col items-center gap-2 ml-6 min-w-[80px]" id="recent-crops"></div>
</div>
<!-- Manual Crop Modal -->
<div id="manual-crop-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
  <div class="bg-[#23263a] rounded-lg shadow-lg p-6 relative w-[90vw] max-w-2xl flex flex-col items-center">
    <button id="manual-crop-cancel" class="absolute top-2 right-2 text-gray-400 hover:text-primary">&times;</button>
    <div class="w-full flex flex-col items-center">
      <div class="flex flex-row w-full justify-center items-start gap-6">
        <div class="relative flex justify-center items-center">
          <canvas id="manual-crop-canvas" class="border border-gray-700 rounded max-w-full max-h-[60vh] bg-black"></canvas>
        </div>
        <div class="flex flex-col items-center">
          <div class="mb-2 text-xs text-gray-400">Crop Preview</div>
          <canvas id="manual-crop-preview" class="border border-gray-700 rounded bg-[#181a20] max-w-[180px] max-h-[180px]"></canvas>
        </div>
      </div>
      <div class="flex flex-row gap-4 mt-4">
        <button id="manual-crop-save-original" class="px-4 py-2 bg-blue-700 text-white rounded shadow hover:bg-blue-800">Save Original</button>
        <button id="manual-crop-save-crop" class="px-4 py-2 bg-green-700 text-white rounded shadow hover:bg-green-800" disabled>Save Crop</button>
      </div>
    </div>
  </div>
</div>
<script>
let currentImageId = null;
let multiSelectMode = false;
let selectedCrops = new Set();
let cropsCache = [];

function showLoading() {
  document.getElementById('main-image').classList.add('hidden');
  document.getElementById('main-image-meta').classList.add('hidden');
  document.getElementById('rotation-buttons').classList.add('hidden');
  document.getElementById('main-image-loader').classList.remove('hidden');
  document.getElementById('yolo-crops-grid').innerHTML = `<div id='yolo-loading' class='col-span-2 text-center text-gray-500'>Detecting people with YOLO...</div>`;
  document.getElementById('confirm-multiselect-btn').classList.add('hidden');
  multiSelectMode = false;
  selectedCrops.clear();
}



function showImageAndCrops(image) {
  // Main image
  const img = document.getElementById('main-image');
  img.src = image.image_url;
  img.classList.remove('hidden');
  document.getElementById('main-image-loader').classList.add('hidden');
  document.getElementById('main-image-meta').classList.remove('hidden');
  document.getElementById('rotation-buttons').classList.remove('hidden');
  document.getElementById('main-image-id').textContent = image.id;
  document.getElementById('main-image-filename').textContent = image.filename;
}

// Global flag to prevent multiple simultaneous rotations
let isRotating = false;

function rotateImage(direction) {
  if (!currentImageId || isRotating) return;
  
  // Prevent multiple simultaneous rotations
  if (document.getElementById('rotate-cw-btn').disabled || document.getElementById('rotate-ccw-btn').disabled) {
    return;
  }
  
  isRotating = true;
  
  // Show loading state on the button
  const btn = direction === 'cw' ? document.getElementById('rotate-cw-btn') : document.getElementById('rotate-ccw-btn');
  const originalContent = btn.innerHTML;
  btn.innerHTML = '<div class="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-white mr-2"></div>Rotating...';
  btn.disabled = true;
  
  fetch(`/api/rotate_image_by_id/${currentImageId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ direction })
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      console.log(`Image rotated ${direction}: ${data.message}`);
      
      // Reload the image with cache buster to ensure the rotated image is displayed
      const img = document.getElementById('main-image');
      const newSrc = data.image_url + '?t=' + Date.now();
      img.src = newSrc;
      
      // Force image reload and then reprocess YOLO detection
      img.onload = function() {
        console.log('Image reloaded after rotation, reprocessing YOLO detection...');
        // Show loading state for YOLO processing
        document.getElementById('yolo-crops-grid').innerHTML = '<div class="col-span-2 text-center text-gray-500">Reprocessing YOLO detection...</div>';
        
        // Reprocess YOLO detection after rotation - only once
        setTimeout(() => {
          // Only reload YOLO if we still have the same image
          if (currentImageId === data.image_id) {
            fetch('/api/cropper/yolo', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ image_id: currentImageId })
            })
            .then(resp => resp.json())
            .then(cropData => {
              if (cropData.success) {
                showCrops(cropData.crops);
              } else {
                // Handle different types of errors
                let errorMessage = 'YOLO error';
                if (cropData.error) {
                  if (cropData.error.includes('corrupted') || cropData.error.includes('invalid')) {
                    errorMessage = 'Image file is corrupted';
                    // Add a button to skip this corrupted image
                    document.getElementById('yolo-crops-grid').innerHTML = `
                      <div class="col-span-2 text-center text-gray-400">
                        <div class="mb-4">${errorMessage}</div>
                        <button onclick="skipCorruptedImage()" class="px-4 py-2 bg-red-700 text-white rounded shadow hover:bg-red-800">
                          Skip Corrupted Image
                        </button>
                      </div>`;
                    return;
                  } else {
                    errorMessage = cropData.error;
                  }
                }
                document.getElementById('yolo-crops-grid').innerHTML = `<div class="col-span-2 text-center text-gray-400">${errorMessage}</div>`;
              }
            })
            .catch((error) => {
              console.error('YOLO detection error:', error);
              document.getElementById('yolo-crops-grid').innerHTML = '<div class="col-span-2 text-center text-gray-400">YOLO error</div>';
            });
          }
        }, 100);
      };
      
      // If image is already cached, trigger onload manually
      if (img.complete) {
        img.onload();
      }
    } else {
      alert('Error rotating image: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(error => {
    console.error('Error rotating image:', error);
    alert('Error rotating image: ' + error.message);
  })
  .finally(() => {
    // Restore button state
    btn.innerHTML = originalContent;
    btn.disabled = false;
    isRotating = false;
  });
}

function renderCrops(crops) {
  const grid = document.getElementById('yolo-crops-grid');
  grid.innerHTML = '';
  cropsCache = crops;
  // Remove original from grid: only show YOLO crops
  if (crops.length > 0) {
    crops.forEach((crop, idx) => {
      const div = document.createElement('div');
      div.className = 'flex flex-col items-center justify-center flex-1 min-w-0 cursor-pointer border-2 border-transparent';
      div.id = `crop-${idx}`;
      div.innerHTML = `<div class='w-full aspect-square flex items-center justify-center'><img src='data:image/jpeg;base64,${crop.base64}' class='rounded border border-gray-300 w-full h-auto aspect-square object-contain'/></div><div class='text-xs text-gray-500 mt-2'>Crop #${idx+1}</div>`;
      if (selectedCrops.has(idx) && multiSelectMode) div.classList.add('ring-4', 'ring-blue-500');
      div.onclick = (e) => {
        if (multiSelectMode) {
          toggleCropSelection(idx);
        } else {
          saveCrop(idx);
        }
      };
      div.onmousedown = (e) => {
        if (e.shiftKey) {
          enterMultiSelectMode();
          toggleCropSelection(idx);
        }
      };
      grid.appendChild(div);
    });
  } else {
    const msg = document.createElement('div');
    msg.className = 'col-span-2 text-center text-gray-400';
    msg.textContent = 'No people detected.';
    grid.appendChild(msg);
  }
  // Also update main image outline if in multi-select
  const mainImage = document.getElementById('main-image');
  if (multiSelectMode && selectedCrops.has('original')) {
    mainImage.classList.add('ring-4', 'ring-blue-500');
  } else {
    mainImage.classList.remove('ring-4', 'ring-blue-500');
  }
}

function toggleCropSelection(idx) {
  if (selectedCrops.has(idx)) {
    selectedCrops.delete(idx);
  } else {
    selectedCrops.add(idx);
  }
  renderCrops(cropsCache);
  document.getElementById('confirm-multiselect-btn').classList.toggle('hidden', selectedCrops.size === 0);
}

function enterMultiSelectMode() {
  multiSelectMode = true;
  document.getElementById('confirm-multiselect-btn').classList.remove('hidden');
}

function exitMultiSelectMode() {
  multiSelectMode = false;
  selectedCrops.clear();
  document.getElementById('confirm-multiselect-btn').classList.add('hidden');
  renderCrops(cropsCache);
}

function handleSaveOrSkipResponse(data) {
  console.log('handleSaveOrSkipResponse:', data);
  if (data.success) {
    if (data.next_image_id) {
      console.log('Loading next image:', data.next_image_id);
      loadImageAndCrops(data.next_image_id);
    } else if (data.redirect_to) {
      // Redirect to next workflow step
      console.log('Redirecting to:', data.redirect_to);
      window.location.href = data.redirect_to;
    } else {
      // No more uncropped images
      document.getElementById('main-image-loader').innerHTML = '<div class="text-gray-400">No uncropped images found!</div>';
      document.getElementById('yolo-crops-grid').innerHTML = '';
      document.getElementById('skip-btn').classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
      document.getElementById('skip-btn').classList.remove('bg-gray-300', 'text-gray-700');
      document.getElementById('skip-btn').disabled = true;
      document.getElementById('main-image').classList.add('hidden');
      document.getElementById('main-image-meta').classList.add('hidden');
    }
  } else {
    alert('Save failed');
  }
}

let manualCrop = {
  startX: 0, startY: 0, endX: 0, endY: 0, dragging: false, hasSelection: false
};

function openManualCropOverlay() {
  const modal = document.getElementById('manual-crop-modal');
  const canvas = document.getElementById('manual-crop-canvas');
  const preview = document.getElementById('manual-crop-preview');
  const img = document.getElementById('main-image');
  const saveCropBtn = document.getElementById('manual-crop-save-crop');
  const saveOrigBtn = document.getElementById('manual-crop-save-original');
  const cancelBtn = document.getElementById('manual-crop-cancel');
  // Set up canvas
  const tempImg = new window.Image();
  tempImg.onload = function() {
    // Fit canvas to image aspect ratio, max 600x400
    let maxW = 600, maxH = 400;
    let scale = Math.min(maxW / tempImg.naturalWidth, maxH / tempImg.naturalHeight, 1);
    canvas.width = tempImg.naturalWidth;
    canvas.height = tempImg.naturalHeight;
    canvas.style.width = (tempImg.naturalWidth * scale) + 'px';
    canvas.style.height = (tempImg.naturalHeight * scale) + 'px';
    drawManualCropCanvas();
    drawManualCropPreview();
  };
  tempImg.src = img.src;
  modal.classList.remove('hidden');
  manualCrop = { startX: 0, startY: 0, endX: 0, endY: 0, dragging: false, hasSelection: false };
  saveCropBtn.disabled = true;

  function drawManualCropCanvas() {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
    if (manualCrop.hasSelection) {
      const x = Math.min(manualCrop.startX, manualCrop.endX);
      const y = Math.min(manualCrop.startY, manualCrop.endY);
      const w = Math.abs(manualCrop.endX - manualCrop.startX);
      const h = Math.abs(manualCrop.endY - manualCrop.startY);
      ctx.save();
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(x, y, w, h);
      ctx.restore();
    }
  }

  function drawManualCropPreview() {
    if (!manualCrop.hasSelection || !manualCrop.dragging) {
      preview.width = 1;
      preview.height = 1;
      preview.style.display = 'none';
      return;
    }
    preview.style.display = 'block';
    const x = Math.min(manualCrop.startX, manualCrop.endX);
    const y = Math.min(manualCrop.startY, manualCrop.endY);
    const w = Math.abs(manualCrop.endX - manualCrop.startX);
    const h = Math.abs(manualCrop.endY - manualCrop.startY);
    if (w < 1 || h < 1) return;
    // Set preview size to fit max 180x180, keep aspect
    let maxPrev = 180;
    let scale = Math.min(maxPrev / w, maxPrev / h, 1);
    preview.width = w;
    preview.height = h;
    preview.style.width = (w * scale) + 'px';
    preview.style.height = (h * scale) + 'px';
    const pctx = preview.getContext('2d');
    pctx.clearRect(0, 0, preview.width, preview.height);
    pctx.drawImage(tempImg, x, y, w, h, 0, 0, w, h);
  }

  canvas.onmousedown = function(e) {
    manualCrop.dragging = true;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    manualCrop.startX = manualCrop.endX = Math.round((e.clientX - rect.left) * scaleX);
    manualCrop.startY = manualCrop.endY = Math.round((e.clientY - rect.top) * scaleY);
    manualCrop.hasSelection = false;
    drawManualCropCanvas();
    drawManualCropPreview();
    preview.style.display = 'none';
  };
  canvas.onmousemove = function(e) {
    if (!manualCrop.dragging) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    manualCrop.endX = Math.round((e.clientX - rect.left) * scaleX);
    manualCrop.endY = Math.round((e.clientY - rect.top) * scaleY);
    manualCrop.hasSelection = true;
    drawManualCropCanvas();
    drawManualCropPreview();
    document.getElementById('manual-crop-save-crop').disabled = false;
  };
  canvas.onmouseup = function(e) {
    manualCrop.dragging = false;
    preview.style.display = 'block';
    drawManualCropCanvas();
    drawManualCropPreview();
    document.getElementById('manual-crop-save-crop').disabled = !manualCrop.hasSelection;
  };
  canvas.onmouseleave = function() {
    manualCrop.dragging = false;
  };

  saveOrigBtn.onclick = function() {
    // Save as original (remove uncropped, remove names, backup, etc.)
    let payload = { image_id: currentImageId, type: 'original' };
    fetch('/api/cropper/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(resp => resp.json())
    .then(data => {
      closeManualCropOverlay();
      handleSaveOrSkipResponse(data);
    });
  };

  saveCropBtn.onclick = function() {
    if (!manualCrop.hasSelection) return;
    // Calculate crop box
    const x = Math.round(Math.min(manualCrop.startX, manualCrop.endX));
    const y = Math.round(Math.min(manualCrop.startY, manualCrop.endY));
    const w = Math.round(Math.abs(manualCrop.endX - manualCrop.startX));
    const h = Math.round(Math.abs(manualCrop.endY - manualCrop.startY));
    if (w < 10 || h < 10) {
      alert('Crop too small');
      return;
    }
    let payload = { image_id: currentImageId, type: 'manual_crop', x, y, width: w, height: h };
    fetch('/api/cropper/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(resp => resp.json())
    .then(data => {
      closeManualCropOverlay();
      handleSaveOrSkipResponse(data);
    });
  };

  cancelBtn.onclick = closeManualCropOverlay;
}

function closeManualCropOverlay() {
  document.getElementById('manual-crop-modal').classList.add('hidden');
}

// Persistent recent crops (right bar)
let recentCrops = [];
const RECENT_CROPS_KEY = 'visage_recent_crops';

function loadRecentCrops() {
  try {
    const data = localStorage.getItem(RECENT_CROPS_KEY);
    if (data) {
      recentCrops = JSON.parse(data);
    }
  } catch {}
}
function saveRecentCrops() {
  try {
    localStorage.setItem(RECENT_CROPS_KEY, JSON.stringify(recentCrops.slice(-10)));
  } catch {}
}

function renderUpcomingThumbnails(nextImages) {
  const col = document.getElementById('upcoming-thumbnails');
  col.innerHTML = '';
  (nextImages || []).slice(0, 10).forEach(img => {
    const thumb = document.createElement('img');
    thumb.src = img.image_url;
    thumb.alt = img.filename;
    thumb.className = 'max-w-[72px] max-h-[72px] rounded border border-gray-300 cursor-pointer hover:ring-2 hover:ring-blue-400 object-contain bg-white';
    thumb.title = `ID: ${img.id}\n${img.filename}`;
    thumb.onclick = () => loadImageAndCrops(img.id);
    col.appendChild(thumb);
  });
}

function renderRecentCrops() {
  const col = document.getElementById('recent-crops');
  col.innerHTML = '';
  recentCrops.slice(-10).reverse().forEach(crop => {
    const thumb = document.createElement('img');
    thumb.src = crop.image_url;
    thumb.alt = crop.filename;
    thumb.className = 'max-w-[72px] max-h-[72px] rounded border border-green-400 cursor-pointer hover:ring-2 hover:ring-green-600 object-contain bg-white';
    thumb.title = crop.filename;
    thumb.onclick = () => window.open(crop.image_url, '_blank');
    col.appendChild(thumb);
  });
}

function saveCrop(idx) {
  let payload = { image_id: currentImageId, type: 'crop', crop_idx: idx };
  console.log('Saving crop:', payload);
  fetch('/api/cropper/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  })
  .then(resp => resp.json())
  .then(data => {
    console.log('Save response:', data);
    if (data.saved_crop) {
      recentCrops.push(data.saved_crop);
      saveRecentCrops();
    }
    handleSaveOrSkipResponse(data);
  });
}

// Backend requirement: if the original is not selected in multi-select or not saved in the overlay, it should be moved (not found by other programs) and removed from the database.

function loadImageAndCrops(imageId) {
  showLoading();
  fetch(`/api/cropper/image_data?image_id=${imageId}`)
    .then(resp => resp.json())
    .then(data => {
      if (!data.success || !data.image) {
        document.getElementById('main-image-loader').innerHTML = '<div class="text-gray-400">No uncropped images found!</div>';
        document.getElementById('yolo-crops-grid').innerHTML = '';
        document.getElementById('skip-btn').classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
        document.getElementById('skip-btn').classList.remove('bg-gray-300', 'text-gray-700');
        document.getElementById('skip-btn').disabled = true;
        renderUpcomingThumbnails([]);
        return;
      }
      currentImageId = data.image.id;
      showImageAndCrops(data.image);
      renderUpcomingThumbnails(data.next_images || []);
      renderRecentCrops();
      renderUncroppedCount(data.uncropped_count);
      // Now fetch crops
      fetch('/api/cropper/yolo', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image_id: currentImageId })
      })
      .then(resp => resp.json())
      .then(cropData => {
        if (cropData.success) {
          showCrops(cropData.crops);
        } else {
          // Handle different types of errors
          let errorMessage = 'YOLO error';
          if (cropData.error) {
            if (cropData.error.includes('corrupted') || cropData.error.includes('invalid')) {
              errorMessage = 'Image file is corrupted';
              // Add a button to skip this corrupted image
              document.getElementById('yolo-crops-grid').innerHTML = `
                <div class="col-span-2 text-center text-gray-400">
                  <div class="mb-4">${errorMessage}</div>
                  <button onclick="skipCorruptedImage()" class="px-4 py-2 bg-red-700 text-white rounded shadow hover:bg-red-800">
                    Skip Corrupted Image
                  </button>
                </div>`;
              return;
            } else {
              errorMessage = cropData.error;
            }
          }
          document.getElementById('yolo-crops-grid').innerHTML = `<div class="col-span-2 text-center text-gray-400">${errorMessage}</div>`;
        }
      })
      .catch((error) => {
        console.error('YOLO detection error:', error);
        document.getElementById('yolo-crops-grid').innerHTML = '<div class="col-span-2 text-center text-gray-400">YOLO error</div>';
      });
    });
}

document.addEventListener('DOMContentLoaded', function() {
  loadRecentCrops();
  // Initial load: get first uncropped image
  loadImageAndCrops('');
  
  // Add rotation button event listeners
  document.getElementById('rotate-ccw-btn').onclick = function() {
    rotateImage('ccw');
  };
  
  document.getElementById('rotate-cw-btn').onclick = function() {
    rotateImage('cw');
  };
});

document.getElementById('confirm-multiselect-btn').onclick = function() {
  let selected = Array.from(selectedCrops);
  let payload = { image_id: currentImageId, crops: [] };
  selected.forEach(idx => {
    if (idx === 'original') {
      payload.crops.push({ type: 'original' });
    } else {
      payload.crops.push({ type: 'crop', crop_idx: idx });
    }
  });
  fetch('/api/cropper/save_multi', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  })
  .then(resp => resp.json())
  .then(data => {
    exitMultiSelectMode();
    // If any crops are returned, add to recentCrops and persist
    if (data.saved_crops && Array.isArray(data.saved_crops)) {
      data.saved_crops.forEach(crop => {
        recentCrops.push(crop);
      });
      saveRecentCrops();
    } else if (data.saved_crop) {
      recentCrops.push(data.saved_crop);
      saveRecentCrops();
    }
    handleSaveOrSkipResponse(data);
  });
};
document.getElementById('skip-btn').onclick = function() {
  fetch('/api/cropper/skip', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ image_id: currentImageId })
  })
  .then(resp => resp.json())
  .then(handleSaveOrSkipResponse);
};

document.getElementById('delete-btn').onclick = function() {
  if (!currentImageId) return;
  if (!confirm('Are you sure you want to delete this image? This cannot be undone.')) return;
  fetch(`/api/delete_image/${currentImageId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  })
  .then(resp => resp.json())
  .then(handleSaveOrSkipResponse)
  .catch(err => {
    alert('Error deleting image');
  });
};

const mainImage = document.getElementById('main-image');
mainImage.onclick = function(e) {
  if (multiSelectMode) {
    toggleCropSelection('original');
    return;
  }
  openManualCropOverlay();
};
mainImage.onmousedown = function(e) {
  if (e.shiftKey) {
    enterMultiSelectMode();
    toggleCropSelection('original');
  }
};

function showCrops(crops) {
  renderCrops(crops);
}

function renderUncroppedCount(count) {
  let el = document.getElementById('uncropped-count');
  if (!el) {
    el = document.createElement('div');
    el.id = 'uncropped-count';
    el.className = 'text-xs text-gray-500 mb-2 text-center';
    document.getElementById('upcoming-thumbnails').parentElement.insertBefore(el, document.getElementById('upcoming-thumbnails'));
  }
  el.textContent = `Uncropped images remaining: ${count}`;
}

function skipCorruptedImage() {
  if (!currentImageId) return;
  
  console.log('Skipping corrupted image:', currentImageId);
  
  // Mark this image as corrupted in the database and move to next
  fetch('/api/cropper/skip', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ image_id: currentImageId })
  })
  .then(resp => resp.json())
  .then(handleSaveOrSkipResponse)
  .catch(error => {
    console.error('Error skipping corrupted image:', error);
    // If skip fails, try to just move to next image
    loadImageAndCrops('');
  });
}
</script>
{% endblock %} 